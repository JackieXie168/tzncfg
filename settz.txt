/* ======================(function header)========================
Function Name:int setTZ(char **tz){}
Description : To Setup the system date、time by timezone information.
Arguments : char * tz
Return : a string with format "[+|-]hh:mm"
written by Jackie Xie
Date : 2011/08/18
================================================================*/
int setTZ(char *timezone)
{
	struct tm *tptr, time_to_set;
	struct timeval tv;
	struct timezone tz;
	time_t secs;
	int utc = 0;
	int hsecs, msecs = 0, ssecs = 0, tzhour, tzminute;
	int rc;
	char *sHour = StrDup(timezone);
	char *sMin = StrDup(timezone);
	char *sSec = StrDup(timezone);
	char *sTZ = StrDup(timezone);
	bool tz_is_minus = false;

	if(!timezone)
		return -1;

	if(strstr(timezone, "-")) tz_is_minus = true;
	(void) time(&secs);
	tptr = localtime(&secs);
	printf("The timezone is：UTC%s\n", timezone);
	printf("The current date/time：\n");
	printf("	Date：%02d-%02d-%02d\n", 1900+tptr->tm_year, tptr->tm_mon+1, tptr->tm_mday);
	printf("	Time：%02d:%02d:%02d\n\n", tptr->tm_hour, tptr->tm_min, tptr->tm_sec);

	if(strstr(timezone,":") && matchStrPosAt(":", timezone, -1) == 1){
		/*hsecs = atoi(strcutail(sHour, ":", -100)) * 3600;
		msecs = atoi(strmhead(sMin, ":", -100)) * 60;*/
		hsecs = atoi(index_str(sHour, ":", 1)) * 3600;
		msecs = atoi(index_str(sMin, ":", 2)) * 60;
		tzminute = atoi(sMin);
		if(tz_is_minus)
			msecs = msecs * (-1);
	}
	else if(strstr(timezone, ":") && matchStrPosAt(":", timezone, -1) == 2){
		hsecs = atoi(index_str(sHour, ":", 1)) * 3600;
		msecs = atoi(index_str(sMin, ":", 2)) * 60;
		ssecs = atoi(index_str(sSec, ":", 3));
		tzminute = atoi(sMin);
		if(tz_is_minus){
			msecs = msecs * (-1);
			ssecs = ssecs * (-1);
		}
	}
	else{
		hsecs = atoi(sHour) * 3600;
		msecs = 0;
	}

	if(msecs == 0 && ssecs == 0){
		if(hsecs > 0)
			sprintf(sTZ, "GMT+%02d", hsecs/3600);
		else
			sprintf(sTZ, "GMT%02d", hsecs/3600);
	}
	else if(ssecs == 0){
		if(hsecs > 0)
			sprintf(sTZ, "GMT+%02d:%02d", hsecs/3600, msecs/60);
		else
			sprintf(sTZ, "GMT%02d:%02d", hsecs/3600, abs(msecs/60));
	}
	else{
		if(hsecs > 0)
			sprintf(sTZ, "GMT+%02d:%02d:%02d", hsecs/3600, msecs/60, ssecs);
		else
			sprintf(sTZ, "GMT%02d:%02d:%02d", hsecs/3600, abs(msecs/60), abs(ssecs));
	}

	tzhour = atoi(sHour);
	switch(tzhour)
	{
		case -12: nvram_set("ntp_hidden_select", "0"); break;
		case -11: nvram_set("ntp_hidden_select", "1"); break;
		case -10: nvram_set("ntp_hidden_select", "2"); break;
		case -9: nvram_set("ntp_hidden_select", "3"); break;
		case -8: nvram_set("ntp_hidden_select", "4"); break;
		case -7: nvram_set("ntp_hidden_select", "6"); break;
		case -6: nvram_set("ntp_hidden_select", "8"); break;
		case -5: nvram_set("ntp_hidden_select", "10"); break;
		case -4: nvram_set("ntp_hidden_select", "11"); break;
		case -3: if(tzminute == 30) nvram_set("ntp_hidden_select", "12"); else nvram_set("ntp_hidden_select", "13"); break;
		case -2: nvram_set("ntp_hidden_select", "14"); break;
		case -1: nvram_set("ntp_hidden_select", "15"); break;
		case 0: nvram_set("ntp_hidden_select", "17"); break;
		case 1: nvram_set("ntp_hidden_select", "21"); break;
		case 2: nvram_set("ntp_hidden_select", "24"); break;
		case 3: nvram_set("ntp_hidden_select", "26"); break;
		case 4: nvram_set("ntp_hidden_select", "27"); break;
		case 5: if(tzminute == 30) nvram_set("ntp_hidden_select", "29"); else nvram_set("ntp_hidden_select", "28"); break;
		case 6: nvram_set("ntp_hidden_select", "30"); break;
		case 7: nvram_set("ntp_hidden_select", "31"); break;
		case 8: nvram_set("ntp_hidden_select", "33"); break;
		case 9: nvram_set("ntp_hidden_select", "34"); break;
		case 10: nvram_set("ntp_hidden_select", "36"); break;
		case 11: nvram_set("ntp_hidden_select", "37"); break;
		case 12: nvram_set("ntp_hidden_select", "38"); break;
		default:
			break;
	}
	nvram_set("time_zone", sTZ);
	
	utc = hsecs + msecs + ssecs;
	 (void) time(&secs);
	
	if(utc==0)
		tptr = localtime(&secs);
	else{
		secs += utc;
		tptr = gmtime(&secs);
	}

	// Make new system time.
	if ((tv.tv_sec = mktime(tptr)) == (time_t)-1)
	{
		printf("Cannot convert system time\n");
		return -1;
	}

	tz.tz_minuteswest = -(secs / 60);	
	tv.tv_usec = 0;
	rc = settimeofday(&tv, &tz);
	if ( rc != 0)
	{
		printf("Cannot set system time\n");
		printf("settimeofday() failed, " "errno = %d\n",errno);
		return -1;
	}
	else
		printf("settimeofday() successful.\n");


	printf("新時區是：UTC%s\n", timezone);
	printf("更新後的日期和時間分別為:\n");
	printf("	日期: %02d年%02d月%02d日\n", 1900+tptr->tm_year, tptr->tm_mon+1, tptr->tm_mday);
	printf("	時間: %02d:%02d:%02d\n\n", tptr->tm_hour, tptr->tm_min, tptr->tm_sec);

	StrFree(sMin);
	StrFree(sHour);
	StrFree(sSec);
	StrFree(sTZ);
	
	return 0;
}

/* ======================(function header)===========================
Function Name:int setTZName(char *tzname){}
Description : To Setup the system date、time by a specified local timezone name which 
					is encoded according to IEEE 1003.1 (POSIX).
					
					Specifying the Time Zone with TZ
					
					In POSIX systems, a user can specify the time zone by means of the TZ environment variable. For information about how to set environment variables, see section Environment Variables. The functions for accessing the time zone are declared in `time.h'.
					
					You should not normally need to set TZ. If the system is configured properly, the default time zone will be correct. You might set TZ if you are using a computer over a network from a different time zone, and would like times reported to you in the time zone local to you, rather than what is local to the computer.
					
					In POSIX.1 systems the value of the TZ variable can be in one of three formats. With the GNU C library, the most common format is the last one, which can specify a selection from a large database of time zone information for many regions of the world. The first two formats are used to describe the time zone information directly, which is both more cumbersome and less precise. But the POSIX.1 standard only specifies the details of the first two formats, so it is good to be familiar with them in case you come across a POSIX.1 system that doesn't support a time zone information database.
					
					The first format is used when there is no Daylight Saving Time (or summer time) in the local time zone:
					
					std offset
					The std string specifies the name of the time zone. It must be three or more characters long and must not contain a leading colon, embedded digits, commas, nor plus and minus signs. There is no space character separating the time zone name from the offset, so these restrictions are necessary to parse the specification correctly.
					
					The offset specifies the time value you must add to the local time to get a Coordinated Universal Time value. It has syntax like [+|-]hh[:mm[:ss]]. This is positive if the local time zone is west of the Prime Meridian and negative if it is east. The hour must be between 0 and 23, and the minute and seconds between 0 and 59.
					
					The minutes ( mm) and seconds ( ss) are optional. The hour ( hh) shall be required and may be a single digit. The offset following std shall be required. If no offset follows dst, the alternative time is assumed to be one hour ahead of standard time. One or more digits may be used; the value is always interpreted as a decimal number. The hour shall be between zero and 24, and the minutes (and seconds)-if present-between zero and 59. The result of using values outside of this range is unspecified. If preceded by a '-', the timezone shall be east of the Prime Meridian; otherwise, it shall be west (which may be indicated by an optional preceding '+' ).
					
					For example, here is how we would specify Eastern Standard Time, but without any Daylight Saving Time alternative:
					
					EST+5
					The second format is used when there is Daylight Saving Time:
					
					std offset dst [offset],start[/time],end[/time]
					The initial std and offset specify the standard time zone, as described above. The dst string and offset specify the name and offset for the corresponding Daylight Saving Time zone; if the offset is omitted, it defaults to one hour ahead of standard time.
					
					The remainder of the specification describes when Daylight Saving Time is in effect. The start field is when Daylight Saving Time goes into effect and the end field is when the change is made back to standard time. The following formats are recognized for these fields:
					
					"FST+3FDT02:00,J60/00,J304/02"

					This specification describes a fictitious zone that lies three hours east of GMT. It makes a two hour shift forward for daylight savings which begins on March 1st at midnight, and ends on October 31st at 2am. The 'J' designation in the start/end specs signifies that counting starts at one and February 29th is never counted.

     				"FST+3FDT,59,304"

					This specification is significant because of the '59'. The lack of 'J' for the start and end dates, indicates that the Julian day-count begins at zero and ends at 365. If you do the math, you'll see that allows for a total of 366 days. This is fine in leap years, but in non-leap years '59' (Feb-29) does not exist.
					
					Jn
					This specifies the Julian day, with n between 1 and 365. February 29 is never counted, even in leap years.

					n
					This specifies the Julian day, with n between 0 and 365. February 29 is counted in leap years.

					Mm.w.d
					This specifies day d of week w of month m. The day d must be between 0 (Sunday) and 6. The week w must be between 1 and 5; week 1 is the first week in which day d occurs, and week 5 specifies the last d day in the month. The month m should be between 1 and 12.
					
					The time fields specify when, in the local time currently in effect, the change to the other time occurs. If omitted, the default is 02:00:00.
					
					For example, here is how you would specify the Eastern time zone in the United States, including the appropriate Daylight Saving Time and its dates of applicability. The normal offset from UTC is 5 hours; since this is west of the prime meridian, the sign is positive. Summer time begins on the first Sunday in April at 2:00am, and ends on the last Sunday in October at 2:00am.
					
					EST+5EDT,M4.1.0/2,M10.5.0/2

Arguments : char * tz
Return : a string with format "std offset dst [offset],start[/time],end[/time]"
written by Jackie Xie
Date : 2011/08/28
===================================================================*/
int setTZName(char *tzname)
{
	char *offsets = StrDup(tzname);
	char stz[12]={0};
	char dtz[12]={0};
	char stz_offset[12]={0};
	char dtz_offset[12]={0};
	char *start_dst = NULL;
	char *end_dst = NULL;
	int len, i = -1, chstr = 0, chnum = 0;
	int stdlen = 0, dstlen = 0, sofflen = 0, dofflen = 0;
	char *times, *day, *week, *month, *year, *tmp;
	datetime currtime, sdst, edst;
	time_t ptime = 0;
	char data[32];
	
	if(!tzname)
		return -1;

	if(strstr(tzname, ","))
	{
		time_t currTime;
		struct tm* pLocalTime=NULL;
	
		times = StrDup("00:00:00");
		day = StrDup("00");
		week = StrDup("0");
		month = StrDup("00");
		year = StrDup("0000");

		currTime = time(NULL);
		pLocalTime = localtime(&currTime);
		strftime(times, 10 ,"%H:%M:%S", pLocalTime);
		strftime(day, 3 ,"%d", pLocalTime);
		strftime(week, 2 ,"%w", pLocalTime);
		strftime(month, 3 ,"%m", pLocalTime);
		strftime(year, 5, "%Y", pLocalTime);
		
		tmp = StrDup(times); currtime.time.hour = atoi(strcutail(tmp, ":", -1));
		tmp = StrDup(times); currtime.time.minute = atoi(GetStrBetweenStr(tmp, ":", ":"));
		tmp = StrDup(times); currtime.time.second = atoi(strmhead(tmp, ":", -2));
		currtime.day = atoi(day);
		currtime.week = atoi(week);
		currtime.month = atoi(month);
		currtime.year = atoi(year);
		printf("current time is %d-%02d-%02dT%02d:%02d:%02dZ\n", currtime.year, currtime.month, currtime.day, currtime.time.hour, currtime.time.minute, currtime.time.second);

		start_dst = StrDup(tzname);
		end_dst = StrDup(tzname);
		tmp = StrDup(tzname);
		strcutail(offsets, ",", -1);
		//printf("offsets = %s\n", offsets);
		start_dst = StrDup(GetStrBetweenStr(tmp, ",", ","));

		/* To convert 'Jn' to 'Mm.w.d' format if '[J]n' is used */	
		if(strstr(start_dst, "J") || !strstr(start_dst, "M")){
			char *tmp = StrDup(start_dst);
			char dst[64], *timetmp = NULL;
			int _days;

			if(strstr(tmp, "/")){
				timetmp = StrDup(start_dst);
				strmhead(timetmp, "/", 1);
				strcutail(tmp, "/", -1);
			}
			if(strstr(tmp, "J"))
				strmhead(tmp, "J", -1);
			_days = atoi(tmp);
			//printf("days = %d\n", _days);
			_days = days2date(_days, dst);
			//printf("days = %d[%s]\n", _days, dst);
			jds2mds(_days, dst);
			dst[sizeof(dst) - 1] = '\0';
			if(timetmp)
				sprintf(start_dst, "%s%s", dst, timetmp);
			else
				sprintf(start_dst, "%s", dst);
			//printf("new start_dst is %s[%s]\n", start_dst, dst);
			StrFree(tmp); StrFree(timetmp);
		}

		/* Parsing Mm.w.d format */		
		if(!strstr(start_dst, "/"))
			sprintf(start_dst, "%s/2", start_dst);
		
		times = StrDup(start_dst);
		day = StrDup(start_dst);
		week = StrDup(start_dst);
		month = StrDup(start_dst);
		
		//sdst.time = atoi(strmhead(times, "/", -1));
		tmp = StrDup(strmhead(times, "/", -1));
		if(strstr(tmp, ":"))
		{
			times = StrDup(tmp); sdst.time.hour = atoi(strcutail(times, ":", -1));
			times = StrDup(tmp); //printf("times : %s\n", times);
			if(strstr(strmhead(times, ":", -1), ":")) sdst.time.minute = atoi(strcutail(times, ":", -1));
			else sdst.time.minute = atoi(times);
			times = StrDup(tmp);
			if(strstr(strmhead(times, ":", -1), ":")) sdst.time.second = atoi(strmhead(times, ":", -1));
			else sdst.time.second = 0;
		}
		else
		{
			sdst.time.hour = atoi(tmp);
			sdst.time.minute = 0;
			sdst.time.second = 0;
		}
			
		sdst.day = atoi(strcutail(strmhead(day, ".", -2), "/", -1));
		sdst.week = atoi(GetStrBetweenStr(week, ".", "."));
		sdst.month = atoi(GetStrBetweenStr(month, "M", "."));

		strmhead(end_dst, ",", -2);

		/* To convert 'Jn' to 'Mm.w.d' format if '[J]n' is used */	
		if(strstr(end_dst, "J") || !strstr(end_dst, "M")){
			char *tmp = StrDup(end_dst);
			char dst[64], *timetmp = NULL;
			int _days;

			if(strstr(tmp, "/")){
				timetmp = StrDup(end_dst);
				strmhead(timetmp, "/", 1);
				strcutail(tmp, "/", -1);
			}
			if(strstr(tmp, "J"))
				strmhead(tmp, "J", -1);
			_days = atoi(tmp);
			//printf("days = %d\n", _days);
			_days = days2date(_days, dst);
			//printf("days = %d[%s]\n", _days, dst);
			jds2mds(_days, dst);
			dst[sizeof(dst) - 1] = '\0';
			if(timetmp)
				sprintf(end_dst, "%s%s", dst, timetmp);
			else
				sprintf(end_dst, "%s", dst);
			//printf("new end_dst is %s[%s]\n", end_dst, dst);
			StrFree(tmp); StrFree(timetmp);
		}

		/* Parsing Mm.w.d format */		
		if(!strstr(end_dst, "/"))
			sprintf(end_dst, "%s/2", end_dst);
		
		times = StrDup(end_dst);
		day = StrDup(end_dst);
		week = StrDup(end_dst);
		month = StrDup(end_dst);
		
		//edst.time = atoi(strmhead(times, "/", -1));
		tmp = StrDup(strmhead(times, "/", -1));
		if(strstr(tmp, ":"))
		{
			times = StrDup(tmp); edst.time.hour = atoi(strcutail(times, ":", -1));
			times = StrDup(tmp);
			if(strstr(strmhead(times, ":", -1), ":")) edst.time.minute = atoi(strcutail(times, ":", -1));
			else edst.time.minute = atoi(times);
			times = StrDup(tmp);
			if(strstr(strmhead(times, ":", -1), ":")) edst.time.second = atoi(strmhead(times, ":", -1));
			else edst.time.second = 0;
		}
		else
		{
			edst.time.hour = atoi(tmp);
			edst.time.minute = 0;
			edst.time.second = 0;
		}

		edst.day = atoi(strcutail(strmhead(day, ".", -2), "/", -1));
		edst.week = atoi(GetStrBetweenStr(week, ".", "."));
		edst.month = atoi(GetStrBetweenStr(month, "M", "."));

		/* To confirm the year for start and end of the daylight saving time */
		if(sdst.month > edst.month)
		{
			if(currtime.month >= sdst.month){
				sdst.year = currtime.year;
				edst.year = currtime.year + 1;
			}
			else if(currtime.month <= edst.month || sdst.month > currtime.month){
				sdst.year = currtime.year - 1;
				edst.year = currtime.year;
			}
			else
				sdst.year = edst.year = currtime.year;
		}
		else if(sdst.month == edst.month)
		{
			if(sdst.week > edst.week || (sdst.week == edst.week && (sdst.day > edst.day || 
				(sdst.day == edst.day && (sdst.time.hour > edst.time.hour || 
				(sdst.time.hour == edst.time.hour && (sdst.time.minute > edst.time.minute ||
				(sdst.time.minute == edst.time.minute && sdst.time.second > edst.time.second))))))))
			{
				sdst.year = currtime.year;
				edst.year = currtime.year + 1;
			}
			else
				sdst.year = edst.year = currtime.year;				
		}
		else
			sdst.year = edst.year = currtime.year;

		printf("start daylight saving time = %s[%4d-%02d-%02dT%02d:%02d:%02dZ]\n", start_dst, sdst.year, sdst.month, dayOfMonth(sdst), sdst.time.hour, sdst.time.minute, sdst.time.second);
		printf("end daylight saving time = %s[%4d-%02d-%02dT%02d:%02d:%02dZ]\n", end_dst, edst.year, edst.month, dayOfMonth(edst), edst.time.hour, edst.time.minute, edst.time.second);
		
		sprintf(data, "%4d-%02d-%02dT%02d:%02d:%02dZ\n", currtime.year, currtime.month,  currtime.day, currtime.time.hour, currtime.time.minute, currtime.time.second);
		ptime = currtime.ptime = str2datetime(data);

		sprintf(data, "%4d-%02d-%02dT%02d:%02d:%02dZ\n", sdst.year, sdst.month,  sdst.day, sdst.time.hour, sdst.time.minute, sdst.time.second);
		sdst.ptime = str2datetime(data);

		sprintf(data, "%4d-%02d-%02dT%02d:%02d:%02dZ\n", edst.year, edst.month,  edst.day, edst.time.hour, edst.time.minute, edst.time.second);
		edst.ptime = str2datetime(data);

		StrFree(times); StrFree(tmp);
	}

	len = strlen(offsets);
	
	chstr = 0; chnum = 0;
	while (offsets[++i] != '\0')
	{
		offsets[stdlen] = toupper(offsets[stdlen]);
		if(isalpha(offsets[i]))
		{
			offsets[stdlen] = toupper(offsets[stdlen]);
			if(!chstr)
			{
				stz[stdlen] = offsets[i];
				stdlen++ ;
			}
			else
			{
				chnum = 1;
				dtz[dstlen] = offsets[i];
				dstlen++ ;
			}
		}
		else if(isdigit(offsets[i]) || offsets[i] == '+' || offsets[i] == '-' || offsets[i] == ':')
		{
			/* If preceded by a '-', the timezone shall be east of the Prime Meridian; 
			 * otherwise, it shall be west (which may be indicated by an optional preceding '+' ).
			 * Note: The +,- definition specifies east and west and not addition or subtraction, 
			 * so be careful. (UTC+1 translates to <Timezone name>-1) 
			 */
			chstr = 1;
			if(!chnum)
			{
				stz_offset[sofflen] = offsets[i];
				sofflen++ ;
			}
			else
			{
				dtz_offset[dofflen] = offsets[i];
				dofflen++ ;
			}
		}
	}
	
	printf("Standard time zone is '%s%s'.\n", stz, stz_offset);
	//printf("Daylight Saving Time zone is '%s%s'.\n", dtz, dtz_offset);
	
	{	
		/* Parsing standard/daylight-saving time zone name */
		char *shour = StrDup(stz_offset);
		char *sminute = StrDup(stz_offset);
		char *ssecond = StrDup(stz_offset);
		char *dhour = StrDup(dtz_offset);
		char *dminute = StrDup(dtz_offset);
		char *dsecond = StrDup(dtz_offset);
		int stzhour = 0,  dtzhour = 0, stzminute = 0, dtzminute = 0, stzsecond = 0, dtzsecond = 0;
		bool stz_is_minus = false, dtz_is_minus = false;

		strcutail(shour, ":", -1);
		if(matchStrPosAt(":", sminute, -1) == 2)
		stzminute = atoi(GetStrBetweenStr(sminute, ":", ":"));
		else if(matchStrPosAt(":", sminute, -1) == 1)
			stzminute = atoi(strmhead(sminute, ":", -1));
		if(strstr(ssecond, ":") && matchStrPosAt(":", ssecond, -1) == 2)
			stzsecond = atoi(strmhead(ssecond, ":", -2));
		else
			stzsecond = 0;

#ifdef ENABLE_TIMEZONE_OFFSET
		if(strstr(dtz_offset, "-")) dtz_is_minus = true;
#else
		if(strstr(dtz_offset, "-")) dtz_is_minus = false;
#endif
		dtzhour = atoi(strcutail(dhour, ":", -1));
		if(matchStrPosAt(":", dminute, -1) == 2)
		dtzminute = atoi(GetStrBetweenStr(dminute, ":", ":"));
		else if(matchStrPosAt(":", dminute, -1) == 1)
			dtzminute = atoi(strmhead(dminute, ":", -1));
		if(strstr(dsecond, ":") && matchStrPosAt(":", dsecond, -1) == 2)
			dtzsecond = atoi(strmhead(dsecond, ":", -2));
		else
			dsecond = 0;
/*		
		shour = index_str(shour, ":", 1);
		stzminute = atoi(index_str(sminute, ":", 2));
		stzsecond = atoi(index_str(ssecond, ":", 3));
		dtzhour = atoi(index_str(dhour, ":", 1));
		dtzminute = atoi(index_str(dminute, ":", 2));
		dtzsecond = atoi(index_str(dsecond, ":", 3));
*/
		if(dtz_is_minus){
			dtzminute = dtzminute * (-1);
			dtzsecond = dtzsecond * (-1);
		}

		if(strstr(stz, "GMT") || strstr(stz, "UTC") || !strcmp(stz, ""))
			stzhour = atoi(shour);
		else
			stzhour = atoi(shour) * (-1);

#ifdef ENABLE_TIMEZONE_OFFSET
		if(stzhour < 0 || ((strstr(stz, "GMT") || strstr(stz, "UTC") || !strcmp(stz, "")) && strstr(shour, "-"))
			|| (!strcmp(shour, "00") && !strstr(shour, "-") && !(strstr(stz, "GMT") || strstr(stz, "UTC") || !strcmp(stz, ""))))
			stz_is_minus = true;

		if(stz_is_minus){
			stzminute = stzminute * (-1);
			stzsecond = stzsecond * (-1);
		}

		if((stz_is_minus && (abs(stzhour) > abs(dtzhour) || ((abs(dtzhour) - abs(stzhour) == 0) && (abs(stzminute) > abs(dtzminute)
			|| ((stzminute - dtzminute == 0) && abs(stzsecond) > abs(dtzsecond))))))
				|| (dtz_is_minus && (abs(stzhour) < abs(dtzhour) || ((abs(dtzhour) - abs(stzhour) == 0) && (abs(stzminute) < abs(dtzminute)
					|| ((stzminute - dtzminute == 0) && abs(stzsecond) < abs(dtzsecond)))))))
			dtz_is_minus = true;
		else
			dtz_is_minus = false;

		dtzsecond += stzsecond;
		if(dtzsecond >= 60){
			dtzsecond %= 60;
			++dtzminute;
		}
		else if((!dtz_is_minus && dtzsecond < 0 && dtzhour != 0) || (dtz_is_minus && abs(dtzsecond) >60)){
			dtzsecond += 60;
			--dtzminute;
		}
		else if(dtz_is_minus && dtzsecond > 0){
			dtzsecond -= 60;
			++dtzminute;
		}

		dtzminute += stzminute;
		if(dtzminute >= 60){
			dtzminute %= 60;
			++dtzhour;
		}
		else if((!dtz_is_minus && dtzminute < 0 && dtzhour != 0) || (dtz_is_minus && abs(dtzminute) >60)){
			dtzminute += 60;
			--dtzhour;
		}
		else if(dtz_is_minus && dtzminute > 0){
			dtzminute -= 60;
			++dtzhour;
		}

		if(!dtz_is_minus && dstlen && !dofflen || (dtzhour == 0 && dtzminute ==0 && dtzsecond == 0))
			dtzhour += stzhour + 1; 
		else if(dtzhour != 0)
			dtzhour += stzhour;
		else 
			dtzhour = stzhour;

#else
		if(!dtz_is_minus) dtzhour = dtzhour * (-1);
		if((dstlen && !dofflen) || dtzhour == 0){
			dtzhour = stzhour + 1;
			dtzminute = stzminute;
			dtzsecond = stzsecond;
		}
#endif

		if(dtzhour == 0 && (dtzminute < 0 || dtzsecond < 0))
			dtz_is_minus = true;

		if((strstr(stz_offset, ":") || strstr(dtz_offset, ":")) && ((dtzminute != 0 || dtzsecond != 0) || (stzminute != 0 || stzsecond != 0)))
		{
			if(dtzhour > 0)
				sprintf(dtz_offset, "+%02d:%02d:%02d", dtzhour, dtzminute, dtzsecond);
			else if(dtzhour == 0 && dtz_is_minus)
				sprintf(dtz_offset, "-%02d:%02d:%02d", dtzhour, abs(dtzminute), abs(dtzsecond));
			else
				sprintf(dtz_offset, "%02d:%02d:%02d", dtzhour, abs(dtzminute), abs(dtzsecond));
			if(stzhour > 0)
				sprintf(stz_offset, "+%02d:%02d:%02d", stzhour, stzminute, stzsecond);
			else if(stzhour == 0 && stz_is_minus)
				sprintf(stz_offset, "-%02d:%02d:%02d", stzhour, abs(stzminute), abs(stzsecond));
			else
				sprintf(stz_offset, "%02d:%02d:%02d", stzhour, abs(stzminute), abs(stzsecond));
		}
		else
		{
			if(dtzhour > 0)
				sprintf(dtz_offset, "+%02d", dtzhour);
			else
				sprintf(dtz_offset, "%02d", dtzhour);
			if(stzhour > 0)
				sprintf(stz_offset, "+%02d", stzhour);
			else
				sprintf(stz_offset, "%02d", stzhour);
		}
		StrFree(shour); StrFree(sminute);
	}
	
	if(dstlen) printf("Daylight Saving Time zone is '%s%s'.\n\n", dtz, dtz_offset);
	/* improve accuracy in timezone configuration */
	bool duringTheDST = (currtime.year > sdst.year && (currtime.year == edst.year && 
		(currtime.month < edst.month || (currtime.month == edst.month &&
			(currtime.day < dayOfMonth(edst) || (currtime.day == dayOfMonth(edst) && 
				(currtime.time.hour < edst.time.hour || (currtime.time.hour == edst.time.hour && 
					(currtime.time.minute < edst.time.minute || (currtime.time.minute == edst.time.minute && currtime.time.second < edst.time.second)))))))))) ||
		(currtime.year == sdst.year && 
			(currtime.month > sdst.month || (currtime.month == sdst.month && 
				(currtime.day > dayOfMonth(sdst) || (currtime.day == dayOfMonth(sdst) && 
					(currtime.time.hour > sdst.time.hour || (currtime.time.hour == sdst.time.hour && (currtime.time.minute > sdst.time.minute || 
						(currtime.time.minute == sdst.time.minute && currtime.time.second > sdst.time.second)))))))) &&
		(currtime.year < edst.year || (currtime.year == edst.year &&
			(currtime.month < edst.month || (currtime.month == edst.month && 
				(currtime.day < dayOfMonth(edst) || (currtime.day == dayOfMonth(edst) && 
					(currtime.time.hour < edst.time.hour) || (currtime.time.hour == edst.time.hour && (currtime.time.minute < edst.time.minute || 
						(currtime.time.minute == edst.time.minute && currtime.time.second < edst.time.second))))))))));
	if(duringTheDST){
	/* if(ptime >= sdst.ptime && ptime <= edst.ptime) */
	/*if((currtime.year > sdst.year && currtime.year == edst.year && currtime.day <= dayOfMonth(edst)) ||
		(currtime.year == sdst.year && currtime.month >= sdst.month && currtime.day >= dayOfMonth(sdst))) */
		setTZ(dtz_offset);
		nvram_set("localtimezone", dtz_offset);
		nvram_set("daylight_savings_used", "true");
		nvram_set("ntpadjust", "1");
	}
	else{
		setTZ(stz_offset);
		nvram_set("localtimezone", stz_offset);
		nvram_set("daylight_savings_used", "false");
		nvram_set("ntpadjust", "0");
	}

	StrFree(offsets); StrFree(start_dst); StrFree(end_dst);
	return 0;
}
